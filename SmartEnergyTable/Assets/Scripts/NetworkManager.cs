using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Grpc.Core;
using Network;
using UnityEngine;
using UnityEngine.SceneManagement;
using ZXing.QrCode;

public sealed class NetworkManager : MonoBehaviour
{
    //This is the server address for the backend.
    public string serverAddr;

    //The objectLibrary is a list of prefabs. As we're not using many different tokens it's more efficient to store them in an array.
    //The library is filled in the editor. Rather than loading them from Resources when we need them.
    public List<GameObject> objectLibrary = new List<GameObject>();

    //To make the life of developers easier the _prefabLookup returns the index for the objectLibrary based on the name of the prefab.
    private readonly Dictionary<string, int> _prefabLookUp = new Dictionary<string, int>();

    //Static instance so there is only 1 NetworkManager
    private static NetworkManager _instance;
    private Channel _channel;
    private Client _client;
    private readonly Queue<Action> _actionQueue = new Queue<Action>();


    private readonly string _userId = Guid.NewGuid().ToString(); //Generate a new GUID as userId.
    private string _roomId = "";
    private bool _master;
    private bool _connected;
    private bool _sceneLoaded = true;

    //This is a representation of the current scene according to the server. This manages all the tokens.
    //Key (string) is the uuid generated by the server on AddToken. Value (GameObject) is the token.
    private readonly Dictionary<string, GameObject> _currentScene = new Dictionary<string, GameObject>();

    //_uuidLookUp is the same as the _currentScene dictionary except using GameObjects as value and uuid as key.
    //When using collision systems like RayCasts this dictionary can be used to (re)move objects in the scene.
    private readonly Dictionary<GameObject, string> _uuidLookUp = new Dictionary<GameObject, string>();

    private void Awake()
    {
        if (_instance == null)
        {
            _instance = this;
            //We want the network manager to exist in every scene, so we need to call DontDestroyOnLoad on this gameObject.
            DontDestroyOnLoad(gameObject);

            //Fill the prefab lookup 
            for (var i = 0; i < objectLibrary.Count; i++)
            {
                _prefabLookUp[objectLibrary[i].name] = i;
            }

            //Create the gRPC channel and client
            _channel = new Channel(serverAddr, ChannelCredentials.Insecure);
            _client = new Client(new SmartEnergyTableService.SmartEnergyTableServiceClient(_channel));
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void OnApplicationPause(bool pauseStatus)
    {
        if (Application.platform == RuntimePlatform.Android && pauseStatus)
            OnApplicationQuit();
    }

    private void OnApplicationQuit()
    {
        Debug.Log("OnApplicationQuit()");
        if (SceneManager.GetActiveScene().buildIndex != 0
        ) //If we are on the Launcher menu we have no room to leave.
            _client.LeaveRoom(_roomId, _userId); //Leave the room before we shutdown.
        //Shutdown the channel synchronously to avoid bugs.
        _channel.ShutdownAsync().Wait();
    }


    // Update is called once per frame and runs on the main thread.
    private void Update()
    {
        //The update from the JoinRoom adds actions to the queue. We perform these actions in Update() to run them on the main thread.
        //Unity doesn't support multithreaded calls to the engine like 'Instantiate'.
        lock (_actionQueue)
        {
            while (_actionQueue.Count > 0)
            {
                _actionQueue.Dequeue()();
            }
        }
    }


    //IsMaster can be used in UI elements to show a "master" only view.
    public bool IsMaster => _master;
    public string SessionID => _roomId;

    #region RPCs

    /*
     * CreateRoom is an abstraction over the RPC. This function creates a room, sets the roomId and master.
     * Then joins the newly created room.
     */
    public void CreateRoom()
    {
        if (_roomId != "")
            return;
        var room = _client.CreateRoom();
        _roomId = room.Id;
        _master = true;
        JoinRoom(_roomId);
    }


    /*
     * LoadSceneAsync is a used as a coroutine to load a scene asynchronously.
     * @param sceneBuildIndex: this is the build index created by the Unity Editor in 'File->Build Settings'.
     */
    private IEnumerator LoadSceneAsync(int sceneBuildIndex)
    {
        _sceneLoaded = false;

        var asyncLoad = SceneManager.LoadSceneAsync(sceneBuildIndex);

        // Wait until the asynchronous scene fully loads
        while (!asyncLoad.isDone)
        {
            yield return null;
        }

        _sceneLoaded = true;
    }

    /*
     * ProcessDiffs is a coroutine that processes the diffs from a patch
     * @param diffs: this is a list of the diffs. This coroutine will loop through this and execute the action specified
     * by the diff.
     */
    private IEnumerator ProcessDiffs(IEnumerable<Diff> diffs)
    {
        // If the scene is not fully loaded we need te wait before processing diffs or we risk instantiating/moving/destroying
        // objects in the wrong scene.
        while (!_sceneLoaded)
            yield return null;
        foreach (var diff in diffs)
        {
            switch (diff.Action)
            {
                case Diff.Types.Action.Add:
                    var obj = Instantiate(objectLibrary[diff.Token.ObjectIndex],
                        new UnityEngine.Vector3
                        {
                            x = diff.Token.Position.X,
                            y = diff.Token.Position.Y,
                            z = diff.Token.Position.Z
                        }, Quaternion.identity);
                    _currentScene.Add(diff.Token.ObjectId, obj);
                    break;
                case Diff.Types.Action.Delete:
                    Destroy(_currentScene[diff.Token.ObjectId]);
                    _currentScene.Remove(diff.Token.ObjectId);
                    break;
                case Diff.Types.Action.Move:
                    _currentScene[diff.Token.ObjectId].transform.position = new UnityEngine.Vector3(
                        diff.Token.Position.X,
                        diff.Token.Position.Y,
                        diff.Token.Position.Z
                    );
                    break;
                default:
                    //We should never come here, but ReShaper won't shut up about 'missing default case'.
                    break;
            }
        }
    }


    /*
     * JoinRoom uses the RPC callback to manage the game state managed by the server.
     * This function starts a long-running task that enqueues actions on every update from the server.
     */
    public void JoinRoom(string id)
    {
        //If we're not the master, the roomId won't be set yet.
        if (_roomId == "")
            _roomId = id;
        Task.Run(async () =>
        {
            _connected = true;
            await _client.JoinRoom(id, _userId, patch =>
            {
                lock (_actionQueue)
                {
                    _actionQueue.Enqueue(() =>
                    {
                        _master = patch.IsMaster; // This is true if the master switched.

                        //Load the scene if it is not the currentScene, meaning the scene has changed.
                        if (patch.SceneId != SceneManager.GetActiveScene().buildIndex)
                        {
                            StartCoroutine(LoadSceneAsync(patch.SceneId));
                        }

                        //If the _currentScene is empty we want to process the entire history as this might mean we joined
                        //later on and some object might not be send through the 'normal' diffs.
                        if (_currentScene.Count == 0)
                        {
                            Debug.Log("Process patch history...");
                            Debug.Log(patch.History.Count);
                            var history = new Diff[patch.History.Count];
                            for (var i = 0; i < patch.History.Count; i++)
                            {
                                history[i] = patch.History[i];
                            }

                            StartCoroutine(ProcessDiffs(history));
                        }
                        else
                        {
                            Debug.Log("Applying patches...");
                            var diffs = new Diff[patch.Diffs.Count];
                            for (var i = 0; i < patch.Diffs.Count; i++)
                            {
                                diffs[i] = patch.Diffs[i];
                            }

                            StartCoroutine(ProcessDiffs(diffs));
                        }

                        _uuidLookUp.Clear();
                        foreach (var keyValuePair in _currentScene)
                        {
                            _uuidLookUp.Add(keyValuePair.Value, keyValuePair.Key);
                        }
                    });
                }
            });
            _connected = false;
            LeaveRoom(); // Leave the room when the patches stop (causes are: RPC failure or master left).
        });
    }

    /*
     * SaveRoom is an abstraction to make saving a room as simple as possible.
     */
    public void SaveRoom()
    {
        _client.SaveRoom(new RoomUser
        {
            Id = _roomId,
            UserId = _userId
        });
    }

    /*
     * AddToken is an abstraction of the AddToken RPC.
     * @param prefab: the name of the prefab of the token. This is case sensitive.
     * @param position: UnityEngine version of the Vector3 class. This is the position of a newly placed token.
     */
    public void AddToken(string prefab, UnityEngine.Vector3 position)
    {
        _client.AddToken(_roomId, _userId, _prefabLookUp[prefab], position);
    }

    /*
     * RemoveToken is used to delete a token from the scene it's uuid.
     * @param uuid: the ObjectID that can be found in the _currentScene.
     */
    public void RemoveToken(string uuid)
    {
        _client.RemoveToken(_roomId, _userId, uuid);
    }

    /*
     * RemoveToken is used to delete a token from the scene by the GameObject. Useful when using collision systems like RayCasts.
     * @param obj: the GameObject that should be removed.
     */
    public void RemoveToken(GameObject obj)
    {
        _client.RemoveToken(_roomId, _userId, _uuidLookUp[obj]);
    }

    /*
     * MoveToken is used to move a token in the scene.
     * @param uuid: the ObjectID that can be found in the _currentScene.
     * @param position: UnityEngine version of the Vector3 class. This is the new position of an existing token.
     */
    public void MoveToken(string uuid, UnityEngine.Vector3 position)
    {
        _client.MoveToken(_roomId, _userId, uuid, position);
    }

    /*
     * MoveToken is used to move a token in the scene using the GameObject. Useful when using collision systems like RayCasts.
     * @param obj: the GameObject that should be removed.
     * @param position: UnityEngine version of the Vector3 class. This is the new position of an existing token.
     */
    public void MoveToken(GameObject obj, UnityEngine.Vector3 position)
    {
        _client.MoveToken(_roomId, _userId, _uuidLookUp[obj], position);
    }

    public void ClearScene()
    {
        var uuids = new List<string>();
        foreach (var currentSceneKey in _currentScene.Keys)
        {
            uuids.Add(currentSceneKey);
        }

        foreach (var uuid in uuids)
        {
            _client.RemoveToken(_roomId, _userId, uuid);
        }
    }

    /*
     * LoadScene is an abstraction over the RPC. Before sending the rpc is checks if the requests index is a valid index.
     * @param buildIndex: the sceneBuildIndex found in the Unity Editor. The value can not be negative.
     */
    public void LoadScene(int buildIndex)
    {
        if (buildIndex > SceneManager.sceneCountInBuildSettings - 1)
            throw new IndexOutOfRangeException("buildIndex is out of bounds. Check build settings for valid indices.");
        if (buildIndex < 0)
            throw new IndexOutOfRangeException("buildIndex can not be less than 0");

        _client.ChangeScene(_roomId, _userId, buildIndex);
    }

    /*
     * MoveUsers is used to move all users except the master to the new position.
     * @param newPosition: UnityEngine version of the Vector3 class. This is the new position of all users except the master.
     */
    public void MoveUsers(UnityEngine.Vector3 newPosition)
    {
        _client.MoveUsers(_roomId, _userId, newPosition);
    }

    /*
     * ChangeMaster changes the master from the current master to a new master.
     * @param newMasterId: this is the GUID of the new master.
     */
    public void ChangeMaster(string newMasterId)
    {
        _client.ChangeMaster(_roomId, _userId, newMasterId);
    }

    /*
     * LeaveRoom is used to leave the current room.
     * When called from the master, everyone is kicked from the room. When called from a client, only that client leaves the room.
     * This function should always be called when a session ends otherwise Unity might introduce bugs where Tasks keep running indefinitely.
     */
    public void LeaveRoom()
    {
        if (_connected)
            _client.LeaveRoom(_roomId, _userId); //Leave the room on the server only if we're connected to the server.
        //Clear the network manager after leaving the room.
        SceneManager.LoadScene(0);
        _master = false;
        _roomId = "";
        _currentScene.Clear();
        lock (_actionQueue)
            _actionQueue.Clear();
        _uuidLookUp.Clear();
    }

    #endregion
}